<html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Chapter&nbsp;1.&nbsp;EASY Meta-Programming with Rascal</title><meta content="DocBook XSL Stylesheets V1.75.2" name="generator"><link rel="home" href="index.html" title="Chapter&nbsp;1.&nbsp;EASY Meta-Programming with Rascal"><link rel="next" href="ch01s02.html" title="Rascal Concepts"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table summary="Navigation header" width="100%"><tr><th align="center" colspan="3">Chapter&nbsp;1.&nbsp;EASY Meta-Programming with Rascal</th></tr><tr><td align="left" width="20%">&nbsp;</td><th align="center" width="60%">&nbsp;</th><td align="right" width="20%">&nbsp;<a accesskey="n" href="ch01s02.html">Next</a></td></tr></table><hr></div><div class="chapter" title="Chapter&nbsp;1.&nbsp;EASY Meta-Programming with Rascal"><div class="titlepage"><div><div><h2 class="title"><a name="EASY-Meta-Programming-with-Rascal"></a>Chapter&nbsp;1.&nbsp;EASY Meta-Programming with Rascal</h2></div><div><h3 class="subtitle"><i>Leveraging the Extract-Analyze-SYnthesize Paradigm for
    Meta-Programming</i></h3></div><div><div class="authorgroup">
      <div class="author"><h3 class="author"><span class="firstname">Paul</span> <span class="surname">Klint, Jurgen Vinju,
        Tijs van der Storm</span></h3></div>
    </div></div><div><p class="pubdate">June 26, 2009 (Version 0.2)</p></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="index.html#section.why-a-new-language">A New Language for Meta-Programming</a></span></dt><dd><dl><dt><span class="section"><a href="index.html#section.EASY-programming">EASY Programming</a></span></dt><dt><span class="section"><a href="index.html#N200AE">Rascal</a></span></dt><dt><span class="section"><a href="index.html#N200BD">Benefits of Rascal</a></span></dt><dt><span class="section"><a href="index.html#N2012F">Aim and Scope of this Book</a></span></dt><dt><span class="section"><a href="index.html#N20159">Installing and Running Rascal</a></span></dt><dt><span class="section"><a href="index.html#N20162">Reading Guide</a></span></dt><dt><span class="section"><a href="index.html#N201CF">Typographic Conventions</a></span></dt></dl></dd><dt><span class="section"><a href="ch01s02.html">Rascal Concepts</a></span></dt><dd><dl><dt><span class="section"><a href="ch01s02.html#N2021E">Values</a></span></dt><dt><span class="section"><a href="ch01s02.html#N2022A">Data structures</a></span></dt><dt><span class="section"><a href="ch01s02.html#N20368">Pattern Matching</a></span></dt><dt><span class="section"><a href="ch01s02.html#N203B5">Enumerators</a></span></dt><dt><span class="section"><a href="ch01s02.html#N203CE">Comprehensions</a></span></dt><dt><span class="section"><a href="ch01s02.html#N203F1">Control structures</a></span></dt><dt><span class="section"><a href="ch01s02.html#N2040A">Switching</a></span></dt><dt><span class="section"><a href="ch01s02.html#N20415">Visiting</a></span></dt><dt><span class="section"><a href="ch01s02.html#N20445">Functions</a></span></dt><dt><span class="section"><a href="ch01s02.html#N20452">Syntax Definition and Parsing</a></span></dt><dt><span class="section"><a href="ch01s02.html#N204A5">Rewrite Rules</a></span></dt><dt><span class="section"><a href="ch01s02.html#N204DE">Constraint solving</a></span></dt><dt><span class="section"><a href="ch01s02.html#N204F6">Other features</a></span></dt><dt><span class="section"><a href="ch01s02.html#N2051A">Typechecking and Execution</a></span></dt></dl></dd><dt><span class="section"><a href="ch01s03.html">Some Classical Examples</a></span></dt><dd><dl><dt><span class="section"><a href="ch01s03.html#N2053B">Hello</a></span></dt><dt><span class="section"><a href="ch01s03.html#N20595">Factorial</a></span></dt><dt><span class="section"><a href="ch01s03.html#section.colored-trees">Colored Trees</a></span></dt><dt><span class="section"><a href="ch01s03.html#N2063B">Word Replacement</a></span></dt></dl></dd><dt><span class="section"><a href="ch01s04.html">Problem Solving Strategies</a></span></dt><dd><dl><dt><span class="section"><a href="ch01s04.html#section.defining-extraction">Defining Extraction</a></span></dt><dt><span class="section"><a href="ch01s04.html#section.defining-analysis">Defining Analysis</a></span></dt><dt><span class="section"><a href="ch01s04.html#section.defining-synthesis">Defining Synthesis</a></span></dt></dl></dd><dt><span class="section"><a href="ch01s05.html">Larger Examples</a></span></dt><dd><dl><dt><span class="section"><a href="ch01s05.html#section.motivating-example">Call Graph Analysis</a></span></dt><dt><span class="section"><a href="ch01s05.html#section.analyzing-components">Analyzing the Component Structure of an Application</a></span></dt><dt><span class="section"><a href="ch01s05.html#section.analyzing-java">Analyzing the Structure of Java Systems</a></span></dt><dt><span class="section"><a href="ch01s05.html#section.unitialized-variables">Finding Uninitialized and Unused Variables in a Program</a></span></dt><dt><span class="section"><a href="ch01s05.html#section.McCabe">McCabe Cyclomatic Complexity</a></span></dt><dt><span class="section"><a href="ch01s05.html#section.dataflow">Dataflow Analysis</a></span></dt><dt><span class="section"><a href="ch01s05.html#section.program-slicing">Program Slicing</a></span></dt></dl></dd><dt><span class="section"><a href="ch01s06.html">The Rascal Language</a></span></dt><dd><dl><dt><span class="section"><a href="ch01s06.html#section.types-and-values">Types and Values</a></span></dt><dt><span class="section"><a href="ch01s06.html#section.declarations">Declarations</a></span></dt><dt><span class="section"><a href="ch01s06.html#section.expressions">Expressions</a></span></dt><dt><span class="section"><a href="ch01s06.html#section.statements">Statements</a></span></dt></dl></dd><dt><span class="section"><a href="ch01s07.html">Built-in Operators and Library Functions</a></span></dt><dd><dl><dt><span class="section"><a href="ch01s07.html#section.lib-Benchmark">Benchmark</a></span></dt><dt><span class="section"><a href="ch01s07.html#section.lib-Boolean">Boolean</a></span></dt><dt><span class="section"><a href="ch01s07.html#section.lib-Exception">Exception</a></span></dt><dt><span class="section"><a href="ch01s07.html#section.lib-Graph">Graph</a></span></dt><dt><span class="section"><a href="ch01s07.html#section.lib-Integer">Integer</a></span></dt><dt><span class="section"><a href="ch01s07.html#section.lib-IO">IO</a></span></dt><dt><span class="section"><a href="ch01s07.html#section.lib-JDT">JDT (Eclipse only)</a></span></dt><dt><span class="section"><a href="ch01s07.html#section.lib-LabelledGraph">Labelled Graph</a></span></dt><dt><span class="section"><a href="ch01s07.html#section.lib-List">List</a></span></dt><dt><span class="section"><a href="ch01s07.html#section.lib-Location">Location</a></span></dt><dt><span class="section"><a href="ch01s07.html#section.lib-Map">Map</a></span></dt><dt><span class="section"><a href="ch01s07.html#section.lib-Node">Node</a></span></dt><dt><span class="section"><a href="ch01s07.html#section.lib-Real">Real</a></span></dt><dt><span class="section"><a href="ch01s07.html#section.lib-Relation">Relation</a></span></dt><dt><span class="section"><a href="ch01s07.html#section.lib-RSF">RSF</a></span></dt><dt><span class="section"><a href="ch01s07.html#section.lib-Resource">Resource (Eclipse only)</a></span></dt><dt><span class="section"><a href="ch01s07.html#section.lib-Set">Set</a></span></dt><dt><span class="section"><a href="ch01s07.html#section.lib-String">String</a></span></dt><dt><span class="section"><a href="ch01s07.html#section.lib-Tuple">Tuple</a></span></dt><dt><span class="section"><a href="ch01s07.html#section.lib-UnitTest">UnitTest</a></span></dt><dt><span class="section"><a href="ch01s07.html#section.lib-Value">Value</a></span></dt><dt><span class="section"><a href="ch01s07.html#section.lib-ValueIO">ValueIO</a></span></dt><dt><span class="section"><a href="ch01s07.html#section.lib-View">View (Eclipse only)</a></span></dt><dt><span class="section"><a href="ch01s07.html#section.lib-Void">Void</a></span></dt></dl></dd><dt><span class="section"><a href="ch01s08.html">Table of Built-in Operators</a></span></dt><dt><span class="section"><a href="ch01s09.html">Table of Built-in Functions</a></span></dt><dt><span class="section"><a href="ch01s10.html">Bibliography</a></span></dt><dt><span class="section"><a href="ch01s11.html">Acknowledgements</a></span></dt><dt><span class="glossary"><a href="index.html#section.glossary">Glossary of Terminology</a></span></dt></dl></div>
  

  <div class="warning" title="Warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3>
    <p>Rascal is a work in progress both regarding implementation and
    documentation. The current version of this document is a preview version
    only. Comments labelled "Warning" (like this one) or other
    <em><span class="remark">remarks</span></em> (like this one) are temporary notes that will
    disappear in the final version.</p>
  </div>

  <div class="section" title="A New Language for Meta-Programming"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="section.why-a-new-language"></a>A New Language for Meta-Programming</h2></div></div></div>
    

    <p><span class="emphasis"><em>Meta-programs</em></span> are programs that analyze,
    transform or generate other programs. Ordinary programs work on data;
    meta-programs work on programs. The range of programs to which
    meta-programming can be applied is large: from programs in standard
    languages like C and Java to domain-specific languages for describing
    high-level system models or applications in specialized areas like gaming
    or finance. In some cases, even test results or performance data are used
    as input for meta-programs.</p>

    <p>Rascal is a new language for <span class="emphasis"><em>meta-programming</em></span>,
    this is the activity of writing meta-programs.</p>

    <div class="section" title="EASY Programming"><div class="titlepage"><div><div><h3 class="title"><a name="section.EASY-programming"></a>EASY Programming</h3></div></div></div>
      

      <p>Many meta-programming problems follow a fixed pattern. Starting
      with some input system (a black box that we usually call
      <span class="emphasis"><em>system-of-interest</em></span>), first relevant information is
      extracted from it and stored in an internal representation. This
      internal representation is then analyzed and used to synthesize results.
      If the synthesis indicates this, these steps can be repeated over and
      over again. These steps are shown in <a class="xref" href="index.html#figure.extract-analyze-synthesize-paradigm" title="Figure&nbsp;1.1.&nbsp;EASY: the Extract-Analyze-Synthesize Paradigm">Figure&nbsp;1.1, &ldquo;EASY: the Extract-Analyze-Synthesize Paradigm&rdquo;</a>.</p><div class="figure"><a name="figure.extract-analyze-synthesize-paradigm"></a><p class="title"><b>Figure&nbsp;1.1.&nbsp;EASY: the Extract-Analyze-Synthesize Paradigm</b></p><div class="figure-contents">
          

          <div class="mediaobject"><img src="easy-workflow.png" width="270" alt="EASY: the Extract-Analyze-Synthesize Paradigm"></div>
        </div></div><p><br class="figure-break"></p>

      <p>This is an abstract view on solving meta-programming problems, but
      is it uncommon? No, so let's illustrate it with a few examples.</p>

      <div class="example"><a name="N20067"></a><p class="title"><b>Example&nbsp;1.1.&nbsp;Finding security breaches</b></p><div class="example-contents">
          

          <p><span class="emphasis"><em>Alice</em></span> is system administrator of a large
          online marketplace and she is looking for security breaches in her
          system. The objects-of-interest are the system's log files. First
          relevant entries are extracted. This will include, for instance,
          messages from the SecureShell demon that reports failed login
          attempts. From each entry login name and originating IP address are
          extracted and put in a table (the internal representation in this
          example). These data are analysed by detecting duplicates and
          counting frequencies. Finally results are synthesized by listing the
          most frequently used login names and IP addresses.</p>
        </div></div><p><br class="example-break"></p><div class="example"><a name="N20071"></a><p class="title"><b>Example&nbsp;1.2.&nbsp;A Forensic DSL compiler</b></p><div class="example-contents">
          

          <p><span class="emphasis"><em>Bernd</em></span> is a senior software engineer
          working at the Berlin headquarters of a forensic investigation lab
          of the German government. His daily work is to find common patterns
          in files stored on digital media that have been confiscated during
          criminal investigations. Text, audio and video files are stored in
          zillions of different data formats and each data format requires its
          own analysis technique. For each new investigation ad hoc
          combinations of tools are used. This makes the process very
          labour-intensive and error-prone. Bernd convinces his manager that
          designing a new domain-specific language (DSL) for forensic
          investigations may relieve the pressure on their lab. After
          designing the DSL---let's call it DERRICK---he makes an EASY
          implementation for it. Given a DERRICK program for a specific case
          under investigation, he first extracts relevant information from it
          and analyzes it: which media formats are relevant? Which patterns to
          look for? How should search results be combined? Given this new
          information, Java code is synthesized that uses the various existing
          tools and combines their results.</p>
        </div></div><p><br class="example-break"></p><div class="example"><a name="N2007B"></a><p class="title"><b>Example&nbsp;1.3.&nbsp;Renovating Financial Software</b></p><div class="example-contents">
          

          <p><span class="emphasis"><em>Charlotte</em></span> is software engineer at a large
          financial institution in Paris and she is looking for options to
          connect an old and dusty software system to a web interface. She
          will need to analyze the sources of that system to understand how it
          can be changed to meet the new requirements. The objects-of-interest
          are in this case the source files, documentation, test scripts and
          any other available information. They have to be parsed in some way
          in order to extract relevant information, say the calls between
          various parts of the system. The call information can be represented
          as a binary relation between caller and callee (the internal
          representation in this example). This relation with 1-step calls is
          analyzed and further extended with 2-step calls, 3-step calls and so
          on. In this way call chains of arbitrary length become available.
          With this new information, we can synthesize results by determining
          the entry points of the software system, i.e., the points where
          calls from the outside world enter the system. Having completed this
          first cycle, Charlotte may be interested in which procedures can be
          called from the entry points and so on and so forth. Results will be
          typically represented as pictures that display the relationships
          that were found. In the case of source code analysis, a variation of
          our workflow scheme is quite common. It is then called the
          extract-analyze-view paradigm and is shown in <a class="xref" href="index.html#figure.extract-analyze-view-paradigm" title="Figure&nbsp;1.2.&nbsp;The extract-analyze-view paradigm">Figure&nbsp;1.2, &ldquo;The extract-analyze-view paradigm&rdquo;</a>.</p>
        </div></div><p><br class="example-break"></p><div class="figure"><a name="figure.extract-analyze-view-paradigm"></a><p class="title"><b>Figure&nbsp;1.2.&nbsp;The extract-analyze-view paradigm</b></p><div class="figure-contents">
          

          <div class="mediaobject"><img src="extract-analyze-view-paradigm.png" width="270" alt="The extract-analyze-view paradigm"></div>
        </div></div><p><br class="figure-break"></p><div class="example"><a name="N20098"></a><p class="title"><b>Example&nbsp;1.4.&nbsp;Finding Concurrency Errors</b></p><div class="example-contents">
          

          <p><span class="emphasis"><em>Daniel</em></span> is concurrency researcher at one
          of the largest hardware manufacturers worldwide. He is working from
          an office in the Bay Area. Concurrency is the big issue for his
          company: it is becoming harder and harder to make CPUs faster,
          therefore more and more of them are bundled on a single chip.
          Programming these multi-core chips is difficult and many programs
          that worked fine on a single CPU contain hard to detect concurrency
          errors due to subtle differences in the order of execution that
          results from executing the code on more than one CPU. Here is where
          Daniel enters the picture. He is working on tools for finding
          concurrency errors. First he extracts facts from the code that are
          relevant for concurrency problems and have to do with calls,
          threads, shared variables and locks. Next, he analyzes these facts
          and synthesizes an abstract model that captures the essentials of
          the concurrency behaviour of the program. Finally he runs a
          third-party verification tool with this model as input to do the
          actual verification.</p>
        </div></div><p><br class="example-break"></p><div class="example"><a name="N200A2"></a><p class="title"><b>Example&nbsp;1.5.&nbsp;Model driven engineering</b></p><div class="example-contents">
          

          <p><span class="emphasis"><em>Elisabeth</em></span> is a software architect at a
          large airplane manufacturer and her concern is reliability and
          dependability of airplane control software. She and her team have
          designed a UML model of the control software and have extended it
          with annotations that describe the reliability of individual
          components. She will use this annotated model in two ways: (a) to
          extract relevant information from it to synthesize input for a
          statistical tool that will compute overall system reliability from
          the reliability of individual components; (b) to generate executable
          code that takes the reliability issues into account.</p>
        </div></div><p><br class="example-break"></p>
    </div>

    <div class="section" title="Rascal"><div class="titlepage"><div><div><h3 class="title"><a name="N200AE"></a>Rascal</h3></div></div></div>
      

      <p>With these examples in mind, you have a pretty good picture how
      EASY applies in different use cases. All these cases involve a form of
      <span class="emphasis"><em>meta-programming</em></span>: software programs (in a wide
      sense) are the objects-of-interest that are being analyzed and
      transformed. The Rascal language you are about to learn is designed for
      meta-programming following the EASY paradigm. It can be applied in
      domains ranging from compiler construction and implementing
      domain-specific languages to constraint solving and software
      renovation.</p>

      <p>Since representation of data is central to the approach, Rascal
      provides a rich set of built-in data types. To support extraction and
      analysis, parsing and advanced pattern matching are provided. High-level
      control structures make analysis and synthesis of complex datastructures
      simple.</p>
    </div>

    <div class="section" title="Benefits of Rascal"><div class="titlepage"><div><div><h3 class="title"><a name="N200BD"></a>Benefits of Rascal</h3></div></div></div>
      

      <p>Before you spend your time on studying the Rascal language it may
      help to first hear our elevator pitch about the main benefits offered by
      the language:</p>

      <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
          <p><span class="bold"><strong>Sophisticated built-in data
          types</strong></span> provide standard solutions for many
          meta-programming problems.</p>
        </li><li class="listitem">
          <p><span class="bold"><strong>Safety</strong></span> is achieved by finding
          most errors even before the program is executed and by making common
          errors like missing initializations or wrong pointers
          impossible.<em><span class="remark"> At the time of writing, this checking is done
          during execution.</span></em></p>
        </li><li class="listitem">
          <p><span class="bold"><strong>Pattern matching</strong></span> is used to
          analyze even the most complex datastructures.</p>
        </li><li class="listitem">
          <p><span class="bold"><strong>Syntax definitions</strong></span> make it
          possible to define new and existing languages and to write tools for
          them.</p>
        </li><li class="listitem">
          <p><span class="bold"><strong>Visiting</strong></span> makes it easy to
          traverse datastructures and to extract information from them or to
          synthesize results.</p>
        </li><li class="listitem">
          <p><span class="bold"><strong>Functions as values </strong></span>permit
          programming styles with high re-use.</p>
        </li><li class="listitem">
          <p><span class="bold"><strong>Generic types</strong></span> allow writing
          functions that are applicable for many different types.</p>
        </li><li class="listitem">
          <p><span class="bold"><strong>Local type inference</strong></span> makes
          local variable declarations redundant.</p>
        </li><li class="listitem">
          <p><span class="bold"><strong>Familiar</strong></span> <span class="bold"><strong>syntax</strong></span> in a <span class="emphasis"><em>what-you-see
          is-what-you-get style</em></span> is used even for sophisticated
          concepts and this makes the language easy to learn and easy to
          use.</p>
        </li><li class="listitem">
          <p><span class="bold"><strong>Eclipse integration</strong></span> makes
          Rascal programming a breeze. All familiar tools are at your
          fingertips.</p>
        </li></ul></div>

      <p>Interested? Read on!</p>
    </div>

    <div class="section" title="Aim and Scope of this Book"><div class="titlepage"><div><div><h3 class="title"><a name="N2012F"></a>Aim and Scope of this Book</h3></div></div></div>
      

      <p title="Aim">
        <b>Aim.&nbsp;</b>

        The aim of this book is to give an easy to understand but
        comprehensive overview of the Rascal language and to offer problem
        solving strategies to handle realistic problems that require
        meta-programming. Problems may range from security analysis and model
        extraction to software renovation, domain-specific languages and code
        generation.
      </p>

      <p title="Audience">
        <b>Audience.&nbsp;</b>

        The book is intended for students, practitioners and researchers
        who want to solve meta-programming problems.
      </p>

      <p title="Background">
        <b>Background.&nbsp;</b>

        Readers should have some background in computer science,
        software engineering or programming languages. Familiarity with
        several main stream programming languages and experience with larger
        software projects will make it easier to appreciate the relevance of
        the meta-programming domain that Rascal is addressing. Some
        familiarity with concepts like sets, relations and pattern matching is
        assumed.
      </p>

      <p title="Scope">
        <b>Scope.&nbsp;</b>

        The scope of the book is limited to the Rascal language and its
        applications but does not address implementation aspects of the
        language.
      </p>
    </div>

    <div class="section" title="Installing and Running Rascal"><div class="titlepage"><div><div><h3 class="title"><a name="N20159"></a>Installing and Running Rascal</h3></div></div></div>
      

      <p>See http://www.meta-environment.org/Meta-Environment/Rascal for
      information.</p>
    </div>

    <div class="section" title="Reading Guide"><div class="titlepage"><div><div><h3 class="title"><a name="N20162"></a>Reading Guide</h3></div></div></div>
      

      <div class="figure"><a name="figure.structure-manual"></a><p class="title"><b>Figure&nbsp;1.3.&nbsp;Structure of this Book</b></p><div class="figure-contents">
          

          <div class="mediaobject"><img src="manual-structure.png" width="270" alt="Structure of this Book"></div>
        </div></div><p><br class="figure-break">The structure of this book is shown in <a class="xref" href="index.html#figure.structure-manual" title="Figure&nbsp;1.3.&nbsp;Structure of this Book">Figure&nbsp;1.3, &ldquo;Structure of this Book&rdquo;</a>. It consists of five parts:</p>

      <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
          <p><span class="bold"><strong>Introduction</strong></span>: gives a
          high-level overview of Rascal and consists of <a class="xref" href="index.html#section.why-a-new-language" title="A New Language for Meta-Programming">the section called &ldquo;A New Language for Meta-Programming&rdquo;</a> and <a class="xref" href="ch01s02.html" title="Rascal Concepts">the section called &ldquo;Rascal Concepts&rdquo;</a> . It also presents some simple
          examples in <a class="xref" href="ch01s03.html" title="Some Classical Examples">the section called &ldquo;Some Classical Examples&rdquo;</a>.</p>
        </li><li class="listitem">
          <p><span class="bold"><strong>Problem Solving</strong></span>: describes
          the major problem solving strategies in Rascal's application domain,
          see <a class="xref" href="ch01s04.html" title="Problem Solving Strategies">the section called &ldquo;Problem Solving Strategies&rdquo;</a>.</p>
        </li><li class="listitem">
          <p><span class="bold"><strong>Examples</strong></span>: gives a collection
          of larger examples, see <a class="xref" href="ch01s05.html" title="Larger Examples">the section called &ldquo;Larger Examples&rdquo;</a>.</p>
        </li><li class="listitem">
          <p><span class="bold"><strong>Reference</strong></span>: gives a detailed
          description of the Rascal language, see <a class="xref" href="ch01s06.html" title="The Rascal Language">the section called &ldquo;The Rascal Language&rdquo;</a>, and all built-in operators and
          library functions, see <a class="xref" href="ch01s07.html" title="Built-in Operators and Library Functions">the section called &ldquo;Built-in Operators and Library Functions&rdquo;</a>.</p>
        </li><li class="listitem">
          <p><span class="bold"><strong>Support</strong></span>: gives tables with
          operators, see <a class="xref" href="ch01s08.html#table.all-operators" title="Table&nbsp;1.39.&nbsp;All Operators">Table&nbsp;1.39, &ldquo;All Operators&rdquo;</a>, and library
          functions, see <a class="xref" href="ch01s09.html#table.all-functions" title="Table&nbsp;1.40.&nbsp;All Functions">Table&nbsp;1.40, &ldquo;All Functions&rdquo;</a>, a
          bibliography, see <a class="xref" href="ch01s10.html" title="Bibliography">the section called &ldquo;Bibliography&rdquo;</a>, and a
          glossary, see <a class="xref" href="index.html#section.glossary" title="Glossary of Terminology">Glossary of Terminology</a> that explains many
          concepts that are used in this book and tries to make the book
          self-contained.</p>
        </li></ul></div>
    </div>

    <div class="section" title="Typographic Conventions"><div class="titlepage"><div><div><h3 class="title"><a name="N201CF"></a>Typographic Conventions</h3></div></div></div>
      

      <p>Rascal code fragments are always shown as a listing like
      this:</p><pre class="programlisting">  .. here is some Rascal code ...</pre><p>Interactive
      sessions are show as a screen like this (<em><span class="remark">make a more clear
      typographic distinction between listings and screens</span></em>):</p><pre class="screen"><code class="prompt">rascal&gt;</code> <strong class="userinput"><code><em class="replaceable"><code>Command</code></em>;</code></strong>
<code class="computeroutput"><em class="replaceable"><code>Type</code></em>: <em class="replaceable"><code>Value</code></em></code></pre><p>where:</p>

      <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
          <p><code class="prompt">rascal&gt;</code> is the prompt of the Rascal
          system.</p>
        </li><li class="listitem">
          <p><strong class="userinput"><code>Command</code></strong> is an arbitrary Rascal
          statement or declaration typed in by the user.</p>
        </li><li class="listitem">
          <p><code class="computeroutput">Type: Value</code> is the type of
          the answer followed by the value of the answer as computed by
          Rascal. In some cases, the response will simply be
          <code class="computeroutput">ok</code> when there is no other
          meaningful answer to give.</p>

          <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
            <p>For typographic reasons the output is abbreviated or
            slightly edited in some examples.</p>
          </div>
        </li></ul></div>
    </div>
  </div>

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  <div class="glossary" title="Glossary of Terminology"><div class="titlepage"><div><div><h2 class="title"><a name="section.glossary"></a>Glossary of Terminology</h2></div></div></div><dl><dt>Annotation</dt><dd><p>An annotation is a (name, value) pair that can be attached to a
        datatype value. The value can be retrieved and changed via the name.
        One datatype value can have more than one annotation.</p></dd><dt>ASF</dt><dd><p>Algebraic Specification Formalism. This a notation for
        describing rewrite rules and is mostly used for defining software
        analysis, fact extraction, and software transformation. It is the
        predecessor of Rascal.</p></dd><dt>ASF+SDF</dt><dd><p>The combination of the formalisms ASF and SDF. ASF+SDF can
        describe both the syntax of a language and the operations on that
        language (checking, execution, analysis, transformation). It is the
        predecessor of Rascal.</p></dd><dt>AsFix</dt><dd><p>ASF+SDF Fixed format. A dataformat used to represent parse
        trees. AsFix is a specialized view on ATerms. Important features
        are:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
            <p>The AsFix format is a full parse tree that contains all the
            original layout and comments from the original source code program
            that was parsed.</p>
          </li><li class="listitem">
            <p>The AsFix format is self-descriptive: each subtree contains
            information about the exact grammar production that has been used
            to parse the text that has resulted in that parse tree.</p>
          </li><li class="listitem">
            <p>The AsFix format does not contain source code coordinates
            per se, but a separate tool can easily compute these coordinates
            and add them to the parse tree in the form of annotations.</p>
          </li></ul></div><p>AsFix is the predecessor of the ParseTree format used by
        Rascal</p></dd><dt>ATerm</dt><dd><p>Annotated terms. A dataformat used for the internal
        representation of all data. Distinguishing features are:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
            <p>ATerms are language-independent and can be processed by
            programs in any language.</p>
          </li><li class="listitem">
            <p>ATerms can be annotated with auxiliary information that does
            not affect the tree structure.</p>
          </li><li class="listitem">
            <p>ATerms preserve <span class="emphasis"><em>maximal subterm
            sharing</em></span>. This means that common parts of the data are
            not duplicated but shared. This leads to considerable
            size-reduction of the data.</p>
          </li></ul></div><p>ATerms are the predecessors of the shared PDB implementation
        used in Rascal.</p></dd><dt>Backtracking</dt><dd><p>Backtracking is a general algorithmic method for finding all (or
        some) solutions to some computational problem, in the case of Rascal
        for pattern matching. It incrementally builds candidate matches, and
        abandons each partial match ("backtracks") as soon as it determines
        that it cannot possibly be completed to a valid match.</p></dd><dt>Bag</dt><dd><p>A bag can contain arbitrary values, without any particular
        order, and possibly repeated elements. All elements of a bag have the
        same type. <em><span class="remark">Rascal does not (yet?) support
        bags.</span></em></p></dd><dt>Comprehension</dt><dd><p>An algorithmic schema for computing lists, sets or
        relations.</p></dd><dt>Constraint solving</dt><dd><p>The process of finding solutions to a problem that is only
        specified by the boundary conditions (constraints) that a solution
        should satisfy.</p></dd><dt>Control flow</dt><dd><p>The order in which the statements in a program can be executed.
        Usually represented as a control flow graph.</p></dd><dt>Debugger</dt><dd><p>A debugger allows the step-by-step execution of a
        program.</p></dd><dt>Dataflow</dt><dd><p>The order in which values may be assigned to variables during
        program execution. Usually represented as a data flow graph.</p></dd><dt>Eclipse</dt><dd><p>Interactive Development Environment (IDE) for Java and other
        languages. The Rascal IDE is built on top of Eclipse and IMP.</p></dd><dt>Enumerator</dt><dd><p>A Rascal construct that enumerates all the elements of a given
        value.</p></dd><dt>Function (higher order)</dt><dd><p>A function is a computational entity with typed formal
        parameters and a typed result. When applied to actual parameters, the
        function is applied and the result replaces the function call. A
        higher-order function is a function that has one or more functions as
        parameter.</p></dd><dt>Graph</dt><dd><p>In mathematics a graph is a set of objects (nodes) that may be
        pairwise connected with links (edges). In Rascal, a graph is a binary
        relation in which each tuple represents an edge in the corresponding
        (mathematical) graph.</p></dd><dt>Interactive Development Environment (IDE)</dt><dd><p>A programming environment for the interactive design,
        development, debugging and testing of programs. Eclipse is an example
        of an IDE.</p></dd><dt>IDE Meta Platform (IMP)</dt><dd><p>IMP is an extension of Eclipse and is intended to make it easier
        to add support for new languages to Eclipse. The Rascal implementation
        is part of IMP.</p></dd><dt>Location</dt><dd><p>Data format to describe locations in source code.</p></dd><dt>List</dt><dd><p>A list can contain arbitrary values, with a particular order,
        and possibly repeated elements. All elements of a list have the same
        type.</p></dd><dt>Map</dt><dd><p>A map is a binary relation consisting of 2-tuples (pairs) of the
        form (key, value) that associate each key with a unique value.</p></dd><dt>Meta-Environment</dt><dd><p>The ASF+SDF Meta-Environment is the IDE for writing ASF+SDF
        specifications.</p></dd><dt>Meta-programming</dt><dd><p>The activity of writing programs that manipulate other programs
        as data.</p></dd><dt>Parser</dt><dd><p>A program that performs syntactic analysis on a given input text
        and builds a parse tree.</p></dd><dt>Parse table</dt><dd><p>A parse table is produced by a parse table generator and is an
        efficient representation of grammar that can be used by a
        parser.</p></dd><dt>Parse table generator</dt><dd><p>A parse table generator takes a grammar as input and converts it
        to a parse table to be used by a parser.</p></dd><dt>Parse tree</dt><dd><p>Tree-structured representation of a text that has been analyzed
        by a parser.</p></dd><dt>ParseTree</dt><dd><p>The ParseTree datatype is the parse tree format used in Rascal.
        It is the successor of AsFix.</p></dd><dt>Pattern</dt><dd><p>A structural description of values that is used for
        matching.</p></dd><dt>Pattern matching</dt><dd><p>Matching is an algorithmic method for determining the structural
        similarity of a pattern and a subject value. The pattern may contain
        variables that are bound to corresponding parts of the subject value
        when the match succeeds.</p></dd><dt>Program Data Base (PDB)</dt><dd><p>Subsystem of IMP that is responsible for implementing Rascal's
        datatypes.</p></dd><dt>Polymorphism</dt><dd><p>Functions and datatypes that can handle values of different
        types in a uniform manner.</p></dd><dt>Prettyprinter</dt><dd><p>A prettyprinter converts parse trees to text. The prettyprinter
        uses default rules to insert layout in a parse tree so that its
        corresponding text is presented in a uniform way. Optionally,
        user-defined formatting rules can replace this default
        behaviour.</p></dd><dt>Relation</dt><dd><p>A relation is a set of tuples. All tuples of a relation have the
        same type.</p></dd><dt>Rscript</dt><dd><p>A small scripting language for defining relational expressions.
        Used for the analysis of facts extracted from software. Predecessor of
        Rascal.</p></dd><dt>Relational Algebra</dt><dd><p>An algebra on relations that provides operators on relations
        that yield new relations. Relational algebra uses no variables and
        provides an operational view on relations.</p></dd><dt>Relational calculus</dt><dd><p>Relational calculus provides a more declarative and descriptive
        way to formulate operations on relations and depends on the use of
        variables.</p></dd><dt>Read-Eval-Print-Loop (REPL)</dt><dd><p>Command-line loop that reads user input, evaluates it and prints
        the result.</p></dd><dt>Rewrite rule</dt><dd><p>A rewrite rule consists of a pattern and a replacement. A
        rewrite rule is applied to all subparts of a datastructure and when
        the pattern matches the matching subpart is replaced. Pattern and
        replacement may contain variables and variables in the replacement are
        first replaced by their value before the replacement is
        applied.</p></dd><dt>SDF</dt><dd><p>Syntax Definition Formalism. A notation for describing the
        grammar of programming and application languages. SDF definitions can
        be imported in Rascal.</p></dd><dt>Set</dt><dd><p>A set can contain arbitrary values, without any particular
        order, and no repeated elements. All elements of a set have the same
        type.</p></dd><dt>Side-effect</dt><dd><p>In imperative programming languages like C and Java, assignments
        cause changes in a global state that are visible for other statements
        and procedures.</p></dd><dt>Syntax tree</dt><dd><p>Tree-structured representation of a text that has been analyzed
        by a parser.</p></dd><dt>Summary</dt><dd><p>An error or message summary. A dataformat for the internal
        representation of errors and messages. Summaries are produced by
        checker and compilers and are used by the GUI.</p></dd><dt>Term rewriting</dt><dd><p>Term rewriting is the act of applying a set of rewrite rules to
        a subject value. The rules are applied as long as any pattern in some
        rule matches. The result is the subject value with replacements made
        as prescribed by the matching rules.</p></dd><dt>Traversal</dt><dd><p>The process of visiting all the sub-elements of a larger
        datastructure. The <code class="literal">visit</code> expression and enumerators
        provide traversal functionality in Rascal.</p></dd><dt>Tuple</dt><dd><p>A tuple is an ordered list of values of possibly different type.
        An element of a tuple may have a label by which that element can be
        selected or modified.</p></dd><dt>Type checking</dt><dd><p>The activity to check that all entities in a program are
        declared and are used in a way that is consistent with their declared
        type.</p></dd><dt>Type inference</dt><dd><p>The activity to infer the type of program entities from their
        use.</p></dd></dl></div>

  
</div><div class="navfooter"><hr><table summary="Navigation footer" width="100%"><tr><td align="left" width="40%">&nbsp;</td><td align="center" width="20%">&nbsp;</td><td align="right" width="40%">&nbsp;<a accesskey="n" href="ch01s02.html">Next</a></td></tr><tr><td valign="top" align="left" width="40%">&nbsp;</td><td align="center" width="20%">&nbsp;</td><td valign="top" align="right" width="40%">&nbsp;Rascal Concepts</td></tr></table></div></body></html>